<html>

<head>
    <title>Mosaique</title>

    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="node_modules/itowns/examples/css/example.css">
    <link rel="stylesheet" type="text/css" href="node_modules/itowns/examples/css/LoadingScreen.css">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
</head>

<body>
    <div id="viewerDiv">
        <div id="menuDiv"></div>
    </div>
    <span id="divScaleWidget"> Scale </span>
    <div id="miniDiv"></div>
    <script src="node_modules/itowns/examples/js/GUI/GuiTools.js"></script>
    <script src="node_modules/itowns/dist/itowns.js"></script>
    <script src="node_modules/itowns/examples/js/GUI/LoadingScreen.js"></script>
    <script src="node_modules/itowns/dist/debug.js"></script>
    <script src="Saisie.js"></script>
    <script type="text/javascript">
        const urlParams = new URLSearchParams(window.location.search);
        const serverAPI = urlParams.get('serverapi') ? urlParams.get('serverapi') : 'localhost';
        const portAPI = urlParams.get('portapi') ? urlParams.get('portapi') : 8081;
        console.log(serverAPI, portAPI)

        apiUrl = "http://" + serverAPI + ":" + portAPI
        // Define projection that we will use (taken from https://epsg.io/3946, Proj4js section)
        itowns.proj4.defs('EPSG:2154', '+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');
        /* global itowns, setupLoadingScreen, GuiTools, debug */

        function updateScaleWidget() {
            var pix = 200;
            const point1 = new itowns.THREE.Vector3();
            const point2 = new itowns.THREE.Vector3();
            const mousePosition = new itowns.THREE.Vector2();
            mousePosition.set(0, 0);
            view.getPickingPositionFromDepth(mousePosition, point1);
            mousePosition.set(pix, 0);
            view.getPickingPositionFromDepth(mousePosition, point2);
            var value = point1.distanceTo(point2);
            var unit = 'm';
            if (value >= 1000) {
                value /= 1000;
                unit = 'km';
            }
            divScaleWidget.innerHTML = `${value.toFixed(2)} ${unit}`;
            divScaleWidget.style.width = `${pix}px`;
        }


        itowns.Fetcher.json(apiUrl+'/json/overviews').then ((json) => {
            const overviews = json

            // limite du crs
            const crs = `${overviews.crs.type}:${overviews.crs.code}`
            const xOrigin = overviews.crs.boundingBox.xmin
            const yOrigin = overviews.crs.boundingBox.ymax

            // limite du dataSet
            const xmin = overviews.dataSet.boundingBox.LowerCorner[0]
            const xmax = overviews.dataSet.boundingBox.UpperCorner[0]
            const ymin = overviews.dataSet.boundingBox.LowerCorner[1]
            const ymax = overviews.dataSet.boundingBox.UpperCorner[1]

            var placement = {
                coord: new itowns.Coordinates(crs, (xmax + xmin) * 0.5, (ymax + ymin) * 0.5),
                range: 10000,
            }

            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            var viewerDiv = document.getElementById('viewerDiv');
            // var miniDiv = document.getElementById('miniDiv');

            // Define geographic extent of level 0 : CRS, min/max X, min/max Y
            const resolutionLv0 = overviews.resolution * 2 ** overviews.level.max;
            
            var extent = new itowns.Extent(
                crs,
                xOrigin, xOrigin + ( overviews.tileSize.width * resolutionLv0),
                yOrigin - ( overviews.tileSize.height * resolutionLv0), yOrigin);

            // Instanciate PlanarView*
            view = new itowns.PlanarView(viewerDiv, extent, {
                placement,
                maxSubdivisionLevel: 30,
                //  disableSkirt: false 
            });
            setupLoadingScreen(viewerDiv, view);

            view.isDebugMode = true;
            setupLoadingScreen(viewerDiv, view);
            menuGlobe = new GuiTools('menuDiv', view);
            menuGlobe.gui.width = 300;

            var orthoLayer, graphLayer;
            var orthoConfig, graphConfig;
            let promises = [itowns.Fetcher.json(apiUrl+'/json/ortho'), itowns.Fetcher.json(apiUrl+'/json/graph'), itowns.Fetcher.json(apiUrl+'/json/opi')];
            Promise.all(promises).then((conf) => {
                orthoConfig = conf[0];
                graphConfig = conf[1];
                opiConfig = conf[2];

                orthoConfig.source = new itowns.WMTSSource(orthoConfig.source);
                orthoConfig.source.extentInsideLimit = function (extent) {
                        return true;
                }
                graphConfig.source = new itowns.WMTSSource(graphConfig.source);
                graphConfig.source.extentInsideLimit = function (extent) {
                    return true;
                }
                graphConfig.opacity = 0.2;
                opiConfig.sourceOri = opiConfig.source;

                opiConfig.source = new itowns.WMTSSource(opiConfig.sourceOri);
                opiConfig.source.extentInsideLimit = function (extent) {
                    return true;
                }
                opiConfig.opacity = 0.5;
                orthoLayer = new itowns.ColorLayer('Ortho', orthoConfig);
                view.addLayer(orthoLayer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
                graphLayer = new itowns.ColorLayer('Graph', graphConfig);
                view.addLayer(graphLayer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
                opiLayer = new itowns.ColorLayer('Opi', opiConfig);
                opiLayer.visible = false
                view.addLayer(opiLayer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
                itowns.ColorLayersOrdering.moveLayerToIndex(view, 'Ortho', 0);
                itowns.ColorLayersOrdering.moveLayerToIndex(view, 'Opi', 1);
                itowns.ColorLayersOrdering.moveLayerToIndex(view, 'Graph', 2);

                var saisie = new Saisie({ graphLayer, orthoLayer, graphConfig, orthoConfig, opiLayer, opiConfig, apiUrl });
                saisie.cliche = 'unknown';
                saisie.message = '';
                saisie.coord = 'xxx';
                saisie.color = [0, 0, 0];
                saisie.controllers = {};
                saisie.controllers['select'] = menuGlobe.gui.add(saisie, 'select');
                saisie.controllers['cliche'] = menuGlobe.gui.add(saisie, 'cliche');
                saisie.controllers['cliche'].listen().domElement.parentElement.style.pointerEvents = 'none';
                saisie.controllers['coord'] = menuGlobe.gui.add(saisie, 'coord');
                saisie.controllers['coord'].listen().domElement.parentElement.style.pointerEvents = 'none';
                saisie.controllers['polygon'] = menuGlobe.gui.add(saisie, 'polygon');
                saisie.controllers['undo'] = menuGlobe.gui.add(saisie, 'undo');
                saisie.controllers['redo'] = menuGlobe.gui.add(saisie, 'redo');
                saisie.controllers['clear'] = menuGlobe.gui.add(saisie, 'clear');
                saisie.controllers['message'] = menuGlobe.gui.add(saisie, 'message');
                saisie.controllers['message'].listen().domElement.parentElement.style.pointerEvents = 'none';
                
                viewerDiv.focus();
                view.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, function () {
                    // eslint-disable-next-line no-console
                    console.info('View initialized');
                    updateScaleWidget();
                });
                viewerDiv.addEventListener('mousewheel', function (ev) {
                    updateScaleWidget();
                });
                window.addEventListener('keydown', function (ev) {
                    saisie.keydown(ev);
                    return false;
                });
                window.addEventListener('keyup', function (ev) {
                    saisie.keyup(ev);
                    return false;
                });
                viewerDiv.addEventListener('mousemove', function (ev) {
                    ev.preventDefault();
                    saisie.mousemove(ev);
                    return false;
                }, false);
                viewerDiv.addEventListener('click', function (ev) {
                    ev.preventDefault();
                    saisie.click(ev);
                    return false;
                }, false);

            })

            // instanciate controls
            // eslint-disable-next-line no-new
            let myControl = new itowns.PlanarControls(view, {
                maxAltitude: 80000000,
                enableRotation: false
            });

            // Patch du PlanarControls pour gérer correctement les changements de curseur
            // todo: faire une PR pour iTowns
            myControl.updateMouseCursorType = function updateMouseCursorType() {
                // control state
                const STATE = {
                    NONE: -1,
                    DRAG: 0,
                    PAN: 1,
                    ROTATE: 2,
                    TRAVEL: 3,
                };
                switch (this.state) {
                    case STATE.NONE:
                        this.view.domElement.style.cursor = this.defaultCursor;
                        // this.view.domElement.style.cursor = 'auto';
                        break;
                    case STATE.DRAG:
                        if (this.view.domElement.style.cursor!='wait')
                            this.defaultCursor = this.view.domElement.style.cursor;
                        this.view.domElement.style.cursor = 'move';
                        break;
                    case STATE.PAN:
                        if (this.view.domElement.style.cursor!='wait')
                            this.defaultCursor = this.view.domElement.style.cursor;
                        this.view.domElement.style.cursor = 'cell';
                        break;
                    case STATE.TRAVEL:
                        if (this.view.domElement.style.cursor!='wait')
                            this.defaultCursor = this.view.domElement.style.cursor;
                        this.view.domElement.style.cursor = 'wait';
                        break;
                    case STATE.ROTATE:
                        if (this.view.domElement.style.cursor!='wait')
                            this.defaultCursor = this.view.domElement.style.cursor;
                        this.view.domElement.style.cursor = 'move';
                        break;
                    default:
                        break;
                }
            };

            // Request redraw
            view.notifyChange();

            menuGlobe.addImageryLayersGUI(view.getLayers(function gui(l) { return l.isColorLayer; }));
            debug.createTileDebugUI(menuGlobe.gui, view);
        })
        .catch ( (err) => {
            apiUrl = prompt(`API non accessible à l'adresse renseignée (${apiUrl}). Veuillez entrer une adresse valide :`, apiUrl)
            apiUrlSplit = apiUrl.split('/')[2].split(':')
            window.location.assign(`http://localhost:8000/?serverapi=${apiUrlSplit[0]}&portapi=${apiUrlSplit[1]}`)
        })
    </script>
</body>
</html>
